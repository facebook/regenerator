// Try/catch helper to minimize deoptimizations. Returns a completion
// record like context.tryEntries[i].completion. This interface could
// have been (and was previously) designed to take a closure to be
// invoked without arguments, but in all the cases we care about we
// already have an existing method we want to call, so there's no need
// to create a new function object. We can even get away with assuming
// the method takes exactly one argument, since that happens to be true
// in every case, so we don't have to touch the arguments object. The
// only additional allocation required is the completion record, which
// has a stable shape and so hopefully should be cheap to allocate.
export function tryCatch(fn, obj, arg) {
  try {
    return { type: "normal", arg: fn.call(obj, arg) };
  } catch (err) {
    return { type: "throw", arg: err };
  }
}

export function doneResult() {
  return { value: undefined, done: true };
}

// Returning this object from the innerFn has the same effect as
// breaking out of the dispatch switch statement.
export const ContinueSentinel = {};

export const ObjectPrototype = Object.prototype;
export const hasOwn = ObjectPrototype.hasOwnProperty;
